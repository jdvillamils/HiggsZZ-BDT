#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <sstream>
#include <cmath>
#include <cstdio>
#include <time.h>
#include <TROOT.h>
#include <TTree.h>
#include <TFile.h>
#include <TChain.h>
#include <iostream>
#include <stdio.h>


int ZZandOther(void){
    
    TString path = "https://atlas-opendata.web.cern.ch/atlas-opendata/samples/2020/4lep/";
    
    

    TChain* zchain = new TChain("mini");
    
    //Backgrounds from ZZ
    zchain->AddFile(path+"MC/mc_363490.llll.4lep.root");
    zchain->AddFile(path+"MC/mc_363356.ZqqZll.4lep.root");
    zchain->AddFile(path+"MC/mc_363492.llvv.4lep.root");
    

   
    
    vector<float> *Lep_pt;
    Bool_t TrigE;
    Bool_t TrigM;
    UInt_t Lep_n;
    vector<float> *Lep_phi;
    vector<float> *Lep_eta;
    vector<float> *Lep_E;
    vector<float> *Lep_ptcone30;
    vector<float> *Lep_etcone20;
    vector<unsigned int> *Lep_type;
    vector<int> *Lep_charge;
    vector<float>   *lep_trackd0pvunbiased;
    vector<float>   *lep_tracksigd0pvunbiased;
    vector<float>   *Lep_z0;
    UInt_t          jet_n;
    vector<float>   *jet_pt;
    vector<float>   *jet_eta;
    
    


    //Setting branch address for signal and background
    zchain->SetBranchAddress("lep_pt", &Lep_pt);//, &b_Lep_ptb);
    zchain->SetBranchAddress("trigE", &TrigE);//, &b_TrigEb);
    zchain->SetBranchAddress("trigM", &TrigM);//, &b_TrigMb);
    zchain->SetBranchAddress("lep_n", &Lep_n);//, &b_Lep_nb);
    zchain->SetBranchAddress("lep_phi", &Lep_phi);//, &b_Lep_phib);
    zchain->SetBranchAddress("lep_eta", &Lep_eta);//, &b_Lep_etab);
    zchain->SetBranchAddress("lep_E", &Lep_E);//, &b_Lep_Eb);
    zchain->SetBranchAddress("lep_ptcone30", &Lep_ptcone30);//, &b_Lep_ptcone30b);
    zchain->SetBranchAddress("lep_etcone20", &Lep_etcone20);//, &b_Lep_etcone20b);
    zchain->SetBranchAddress("lep_type", &Lep_type);//, &b_Lep_typeb);
    zchain->SetBranchAddress("lep_charge", &Lep_charge);//, &b_Lep_chargeb);
    zchain->SetBranchAddress("lep_trackd0pvunbiased", &lep_trackd0pvunbiased);//, &b_lep_trackd0pvunbiasedb);
    zchain->SetBranchAddress("lep_tracksigd0pvunbiased", &lep_tracksigd0pvunbiased);//, &b_lep_tracksigd0pvunbiasedb);
    zchain->SetBranchAddress("lep_z0", &Lep_z0);//, &b_Lep_z0b);
    zchain->SetBranchAddress("jet_n", &jet_n);//, &b_jet_nb);
    zchain->SetBranchAddress("jet_pt", &jet_pt);//, &b_jet_ptb);
    zchain->SetBranchAddress("jet_eta", &jet_eta);//, &b_jet_etab);
 
    
    
    //output root file
    
    TFile *target = new TFile("RootFiles/ZZBackground.root","RECREATE");
    
    TTree *zz = new TTree("ZZBackground","ZZ Background");

    //Output/interest Variables
    Float_t fourlepsystemb; //Train
    
    Float_t fourlepsystemptb; //Train

    Float_t invmassz1;
    Float_t invmassz2;
   
    Float_t fourrap;
   
    Float_t foure;



    zz->Branch("FourLepSystemM", &fourlepsystemb);
    
    zz->Branch("FourLepSystempt", &fourlepsystemptb);

    zz->Branch("InvMassZ1", &invmassz1);
  
    zz->Branch("InvMassZ2", &invmassz2);

    zz->Branch("FourLepRapidity", &fourrap);
   
    zz->Branch("FourLepSystemE", &foure);
      
    


/*{
----------------------------------------
        BACKGROUND SECTION
----------------------------------------
}*/

    int nentriesb, nbytesb, b;

    nentriesb = (Int_t)zchain->GetEntries();
    for (b = 0; b < nentriesb; b++)
    {

        nbytesb = zchain->GetEntry(b);
        if(TrigEb || TrigMb)
        {
            
        int goodlep_indexb[Lep_nb];
        int goodlep_nb = 0;
        int lep_indexb =0;
            
            
        for(int i=0; i<Lep_nb; i++)
                {
        TLorentzVector leptempb;  leptempb.SetPtEtaPhiE(Lep_ptb->at(i)/1000., Lep_etab->at(i), Lep_phib->at(i), Lep_Eb->at(i)/1000.);
            
        if( Lep_ptb->at(i) > 5000. && TMath::Abs(Lep_etab->at(i)) < 2.5 && ( (Lep_ptcone30b->at(i)/Lep_ptb->at(i)) < 0.3) && ( (Lep_etcone20b->at(i) / Lep_ptb->at(i)) < 0.3 ) ) 
                    {
		// electron
		if ( Lep_typeb->at(i) == 11 && Lep_ptb->at(i) > 7000. && TMath::Abs(Lep_etab->at(i)) <2.47 ) 
                        {
		  if( TMath::Abs(lep_trackd0pvunbiasedb->at(i))/lep_tracksigd0pvunbiasedb->at(i) < 5 && TMath::Abs(Lep_z0b->at(i)*TMath::Sin(leptempb.Theta())) < 0.5) 
                            {
		    goodlep_nb = goodlep_nb + 1;
		    goodlep_indexb[lep_indexb] = i;
		    lep_indexb++;
                            }
                        }
		//muon
		if ( Lep_typeb->at(i) == 13) 
                        {
		  if( TMath::Abs(lep_trackd0pvunbiasedb->at(i))/lep_tracksigd0pvunbiasedb->at(i) < 3 && TMath::Abs(Lep_z0b->at(i)*TMath::Sin(leptempb.Theta())) < 0.5) 
                            {
		    goodlep_nb = goodlep_nb + 1;
		    goodlep_indexb[lep_indexb] = i;
		    lep_indexb++;
                            }
                        }
                    } // if of lepton classification
                }   //lepton for loop
                      
            if(goodlep_nb == 4 )
	    {
	      
	      int goodlep1_indexb = goodlep_indexb[0];
	      int goodlep2_indexb = goodlep_indexb[1];
	      int goodlep3_indexb = goodlep_indexb[2];
	      int goodlep4_indexb = goodlep_indexb[3];
	      
	      //first lepton pT > 25 GeV, second > 15 GeV and third > 10 GeV		      
	      if (Lep_ptb->at(goodlep1_indexb) > 25000. && Lep_ptb->at(goodlep2_indexb) > 15000. && Lep_ptb->at(goodlep3_indexb) > 10000. ) 
		{ 		 
              
        // TLorentzVector definitions
		  TLorentzVector Lepton_1b  = TLorentzVector();
		  TLorentzVector Lepton_2b  = TLorentzVector();
		  TLorentzVector Lepton_3b  = TLorentzVector();
		  TLorentzVector Lepton_4b  = TLorentzVector();
		  
		  Lepton_1b.SetPtEtaPhiE(Lep_ptb->at(goodlep1_indexb), Lep_etab->at(goodlep1_indexb), Lep_phib->at(goodlep1_indexb),Lep_Eb->at(goodlep1_indexb));
		  Lepton_2b.SetPtEtaPhiE(Lep_ptb->at(goodlep2_indexb), Lep_etab->at(goodlep2_indexb), Lep_phib->at(goodlep2_indexb),Lep_Eb->at(goodlep2_indexb));
		  Lepton_3b.SetPtEtaPhiE(Lep_ptb->at(goodlep3_indexb), Lep_etab->at(goodlep3_indexb), Lep_phib->at(goodlep3_indexb),Lep_Eb->at(goodlep3_indexb));
		  Lepton_4b.SetPtEtaPhiE(Lep_ptb->at(goodlep4_indexb), Lep_etab->at(goodlep4_indexb), Lep_phib->at(goodlep4_indexb),Lep_Eb->at(goodlep4_indexb));
		  
		  
		  // minimisation of difference from the Z mass
		  float delta_Z1b=0; 
		  float delta_Z2b=0; 
		  float InvMassZ1b=0; 
		  float InvMassZ2b=0;
		  float delta_Z1_1b=0; float delta_Z1_2b=0; float delta_Z1_3b=0;
		  float delta_Z2_1b=0; float delta_Z2_2b=0; float delta_Z2_3b=0;
		  float InvMassZ1_1b=0; float InvMassZ1_2b=0; float InvMassZ1_3b=0;
		  float InvMassZ2_1b=0; float InvMassZ2_2b=0; float InvMassZ2_3b=0;
		  float sum_ZZ1b=0; float sum_ZZ2b=0; float sum_ZZ3b=0;
		  
		  // final values
		  float InvMassZ1_minb=0; float InvMassZ2_minb=0; float sum_ZZ_finb=0;
		  
		  
		  float sum_chargesb = Lep_chargeb->at(goodlep1_indexb) + Lep_chargeb->at(goodlep2_indexb) + Lep_chargeb->at(goodlep3_indexb) + Lep_chargeb->at(goodlep4_indexb);			 
		  
		  // step-by-step
		  // opposite charge leptons
		  if ( sum_chargesb == 0  ) 
		    {
         
          
		      int sum_typesb  = Lep_typeb->at(goodlep1_indexb) + Lep_typeb->at(goodlep2_indexb) + Lep_typeb->at(goodlep3_indexb) + Lep_typeb->at(goodlep4_indexb) ;
              
              // type e=11, mu=13
		      // begin case e+e-e+e- or mu+mu-mu+mu-
		      if ( sum_typesb == 44 || sum_typesb == 52  )
			{
			  if ( Lep_typeb->at(goodlep1_indexb) == Lep_typeb->at(goodlep2_indexb) && ( (Lep_chargeb->at(goodlep1_indexb) * Lep_chargeb->at(goodlep2_indexb)) < 0 )  )
			    {
		          InvMassZ1_1b=(Lepton_1b+Lepton_2b).Mag()/1000.;
			      InvMassZ2_1b=(Lepton_3b+Lepton_4b).Mag()/1000.;
			      delta_Z1_1b =  TMath::Abs(InvMassZ1_1b - 91.18); 
			      delta_Z2_1b =  TMath::Abs(InvMassZ2_1b - 91.18);
			    }
			  if ( Lep_typeb->at(goodlep1_indexb) == Lep_typeb->at(goodlep3_indexb)  && ( (Lep_chargeb->at(goodlep1_indexb) * Lep_chargeb->at(goodlep3_indexb)) < 0 ) )
			    {
			      InvMassZ1_2b=(Lepton_1b+Lepton_3b).Mag()/1000.;
			      InvMassZ2_2b=(Lepton_2b+Lepton_4b).Mag()/1000.;
			      delta_Z1_2b =  TMath::Abs(InvMassZ1_2b - 91.18); 
			      delta_Z2_2b =  TMath::Abs(InvMassZ2_2b - 91.18);
			    }
			  if ( Lep_typeb->at(goodlep1_indexb) == Lep_typeb->at(goodlep4_indexb)  && ( (Lep_chargeb->at(goodlep1_indexb) * Lep_chargeb->at(goodlep4_indexb)) < 0 ) )
			    {
			      InvMassZ1_3b=(Lepton_1b+Lepton_4b).Mag()/1000.;
			      InvMassZ2_3b=(Lepton_2b+Lepton_3b).Mag()/1000.;
			      delta_Z1_3b =  TMath::Abs(InvMassZ1_3b - 91.18); 
			      delta_Z2_3b =  TMath::Abs(InvMassZ2_3b - 91.18);
			    }

			  if(delta_Z1_1b < delta_Z2_1b) { InvMassZ1_minb = InvMassZ1_1b; InvMassZ2_minb = InvMassZ2_1b;}
                          if(delta_Z2_1b < delta_Z1_1b) { InvMassZ1_minb = InvMassZ2_1b; InvMassZ2_minb = InvMassZ1_1b;}

			  if(delta_Z1_2b < delta_Z2_2b) { InvMassZ1_minb = InvMassZ1_2b; InvMassZ2_minb = InvMassZ2_2b;}
                          if(delta_Z2_2b < delta_Z1_2b) { InvMassZ1_minb = InvMassZ2_2b; InvMassZ2_minb = InvMassZ1_2b;}

			  if(delta_Z1_3b < delta_Z2_3b) { InvMassZ1_minb = InvMassZ1_3b; InvMassZ2_minb = InvMassZ2_3b;}
                          if(delta_Z2_3b < delta_Z1_3b) { InvMassZ1_minb = InvMassZ2_3b; InvMassZ2_minb = InvMassZ1_3b;}

			} // cases of eeee or mumumumu
              
               if ( sum_typesb == 48 )
			{
			  
			  if ( Lep_typeb->at(goodlep1_indexb) == Lep_typeb->at(goodlep2_indexb)  && ( (Lep_chargeb->at(goodlep1_indexb) * Lep_chargeb->at(goodlep2_indexb)) < 0 ) )
			    {
			      InvMassZ1b=(Lepton_1b+Lepton_2b).Mag()/1000.;
			      InvMassZ2b=(Lepton_3b+Lepton_4b).Mag()/1000.;
			      delta_Z1b =  TMath::Abs(InvMassZ1b - 91.18); 
			      delta_Z2b =  TMath::Abs(InvMassZ2b - 91.18);
			    }
			  if ( Lep_typeb->at(goodlep1_indexb) == Lep_typeb->at(goodlep3_indexb)  && ( (Lep_chargeb->at(goodlep1_indexb) * Lep_chargeb->at(goodlep3_indexb)) < 0 ) )
			    {
			      InvMassZ1b=(Lepton_1b+Lepton_3b).Mag()/1000.;
			      InvMassZ2b=(Lepton_2b+Lepton_4b).Mag()/1000.;
			      delta_Z1b =  TMath::Abs(InvMassZ1b - 91.18); 
			      delta_Z2b =  TMath::Abs(InvMassZ2b - 91.18);
			    }
			  if ( Lep_typeb->at(goodlep1_indexb) == Lep_typeb->at(goodlep4_indexb)  && ( (Lep_chargeb->at(goodlep1_indexb) * Lep_chargeb->at(goodlep4_indexb)) < 0 ) )
			    {
			      InvMassZ1b=(Lepton_1b+Lepton_4b).Mag()/1000.;
			      InvMassZ2b=(Lepton_2b+Lepton_3b).Mag()/1000.;
			      delta_Z1b =  TMath::Abs(InvMassZ1b - 91.18); 
			      delta_Z2b =  TMath::Abs(InvMassZ2b - 91.18);
			    }
			  
			  if(delta_Z1b < delta_Z2b) { InvMassZ1_minb = InvMassZ1b; InvMassZ2_minb = InvMassZ2b;}
			  if(delta_Z2b < delta_Z1b) { InvMassZ1_minb = InvMassZ2b; InvMassZ2_minb = InvMassZ1b;}
			} // eemumu overe
              
              
              if ( (sum_typesb == 44 || sum_typesb == 52 || sum_typesb == 48) )
			{
			  
			  TLorentzVector FourLepSystemb = TLorentzVector();
			  FourLepSystemb = Lepton_1b + Lepton_2b + Lepton_3b + Lepton_4b;
			  float FourLepSystem_Mb = FourLepSystemb.Mag()/1000.;
			  float FourLepSystem_ptb = FourLepSystemb.Pt()/1000.;
			  float FourLepSystem_yb = FourLepSystemb.Rapidity();
              float FourLepSystem_Eb = FourLepSystemb.E()/1000.;
			 

                          //Preselection of good jets
			  int goodjet_nb = 0;
			  int goodjet_indexb = 0;
				 
                  
                  //here goes the stuff
                      fourlepsystemb=FourLepSystem_Mb;
                      fourlepsystemptb=FourLepSystem_ptb;
                      invmassz1=InvMassZ1_minb;
                      invmassz2=InvMassZ2_minb;
                      fourrap=FourLepSystem_yb;
                      foure=FourLepSystem_Eb;
                      zz->Fill();
                  


                  
              }
          }
        }
        }
        
        }
    }
    
        
    zz->Write();
    target->Close();
    return 0;  
}

